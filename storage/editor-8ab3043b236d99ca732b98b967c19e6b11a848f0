{"mode":"editor","version":1,"windowDimensions":{"x":0,"y":22,"width":1920,"height":1090},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/howardchen/BluePrint","buffers":[{"text":"curl --header \"Authorization: key=AIzaSyAazxnPntHsZBK60Jgcnw6R6uNJmeHx7eY\" --header Content-Type:\"application/json\" https://android.googleapis.com/gcm/send  -d \"{\\\"registration_ids\\\":[\\\"APA91bHDa1TdBvvhd-qtOK16RLuoNbBdah_kMIfxh-4saC4ERpmqpvdSTLAVeT8gK0Ej8pA1o430JPuJCsYVe7xRDI29J66NGAFh8cf_yvG2D-syYdjVPT1IxMp8GZ0Pu7S8UJR00E5DLZVdETM8pdzc2xlq0Phw-xCECq3R8yrkRhn_9wZ0lEc\\\"],\\\"data\\\":{\\\"message\\\":\\\"hello\\\"}}\"\ncurl --header \"Authorization: key=AIzaSyAazxnPntHsZBK60Jgcnw6R6uNJmeHx7eY\" --header Content-Type:\"application/json\" https://android.googleapis.com/gcm/send  -d \"{\\\"registration_ids\\\":[\\\"APA91bHDa1TdBvvhd-qtOK16RLuoNbBdah_kMIfxh-4saC4ERpmqpvdSTLAVeT8gK0Ej8pA1o430JPuJCsYVe7xRDI29J66NGAFh8cf_yvG2D-syYdjVPT1IxMp8GZ0Pu7S8UJR00E5DLZVdETM8pdzc2xlq0Phw-xCECq3R8yrkRhn_9wZ0lEc\\\"],\\\"data\\\":{\\\"message\\\":\\\"hello\\\"}}\"\ncurl --header \"Authorization: key=AIzaSyAazxnPntHsZBK60Jgcnw6R6uNJmeHx7eY\" --header Content-Type:\"application/json\" https://android.googleapis.com/gcm/send  -d \"{\\\"registration_ids\\\":[\\\"APA91bHDa1TdBvvhd-qtOK16RLuoNbBdah_kMIfxh-4saC4ERpmqpvdSTLAVeT8gK0Ej8pA1o430JPuJCsYVe7xRDI29J66NGAFh8cf_yvG2D-syYdjVPT1IxMp8GZ0Pu7S8UJR00E5DLZVdETM8pdzc2xlq0Phw-xCECq3R8yrkRhn_9wZ0lEc\\\"],\\\"data\\\":{\\\"message\\\":\\\"hello\\\"}}\"\n","markers":{"markers":{"1":{"id":1,"range":[[2,0],[3,0]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":15,"goalBufferRange":null,"autoscroll":false,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[{"patches":[{"oldRange":[[1,0],[1,0]],"newRange":[[1,0],[2,0]],"oldText":"","newText":"curl --header \"Authorization: key=AIzaSyAazxnPntHsZBK60Jgcnw6R6uNJmeHx7eY\" --header Content-Type:\"application/json\" https://android.googleapis.com/gcm/send  -d \"{\\\"registration_ids\\\":[\\\"APA91bHDa1TdBvvhd-qtOK16RLuoNbBdah_kMIfxh-4saC4ERpmqpvdSTLAVeT8gK0Ej8pA1o430JPuJCsYVe7xRDI29J66NGAFh8cf_yvG2D-syYdjVPT1IxMp8GZ0Pu7S8UJR00E5DLZVdETM8pdzc2xlq0Phw-xCECq3R8yrkRhn_9wZ0lEc\\\"],\\\"data\\\":{\\\"message\\\":\\\"hello\\\"}}\"\n","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[2,0],[2,0]],"newRange":[[2,0],[3,0]],"oldText":"","newText":"curl --header \"Authorization: key=AIzaSyAazxnPntHsZBK60Jgcnw6R6uNJmeHx7eY\" --header Content-Type:\"application/json\" https://android.googleapis.com/gcm/send  -d \"{\\\"registration_ids\\\":[\\\"APA91bHDa1TdBvvhd-qtOK16RLuoNbBdah_kMIfxh-4saC4ERpmqpvdSTLAVeT8gK0Ej8pA1o430JPuJCsYVe7xRDI29J66NGAFh8cf_yvG2D-syYdjVPT1IxMp8GZ0Pu7S8UJR00E5DLZVdETM8pdzc2xlq0Phw-xCECq3R8yrkRhn_9wZ0lEc\\\"],\\\"data\\\":{\\\"message\\\":\\\"hello\\\"}}\"\n","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":true,"range":[[2,186],[2,370]]},"newParams":{"tailed":false,"range":[[2,370],[2,370]]},"deserializer":"MarkerPatch"},{"oldRange":[[2,186],[2,370]],"newRange":[[2,186],[2,369]],"oldText":"APA91bHDa1TdBvvhd-qtOK16RLuoNbBdah_kMIfxh-4saC4ERpmqpvdSTLAVeT8gK0Ej8pA1o430JPuJCsYVe7xRDI29J66NGAFh8cf_yvG2D-syYdjVPT1IxMp8GZ0Pu7S8UJR00E5DLZVdETM8pdzc2xlq0Phw-xCECq3R8yrkRhn_9wZ0lEc\\","newText":"APA91bHDa1TdBvvhd-qtOK16RLuoNbBdah_kMIfxh-4saC4ERpmqpvdSTLAVeT8gK0Ej8pA1o430JPuJCsYVe7xRDI29J66NGAFh8cf_yvG2D-syYdjVPT1IxMp8GZ0Pu7S8UJR00E5DLZVdETM8pdzc2xlq0Phw-xCECq3R8yrkRhn_9wZ0lEc","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[2,369],[2,369]],"newRange":[[2,369],[2,370]],"oldText":"","newText":"\\","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"}],"redoStack":[],"deserializer":"History"},"filePath":"/Users/howardchen/BluePrint/curlcmd.txt","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"64a528d9d3a4f4152861ab5fa26ee04b3f6ad4d9","deserializer":"TextBuffer"},{"text":"\"\"\"\nCS70 Spring 2014:\nHomework 11 -- skeleton\nQuestion 1: Virtual lab\n\nFor Python 2.7\n\"\"\"\nfrom __future__ import division\nimport random\nimport math\nimport matplotlib as mpl, matplotlib.pyplot as plot\n\n################################################################################\n# Useful util functions:\n################################################################################\ndef linspace(a,b,n):\n    # Returns n numbers evenly spaced between a and b, inclusive\n    return [(a+(b-a)*i/(n-1)) for i in xrange(n)]\n\n################################################################################\n# Convenient helper functions:\n# You may use these if you want or you could write everything on your own.\n# NOTE: NOT ALL OF THESE ARE FILLED IN; YOU NEED TO WRITE SOME OF THEM ON YOUR OWN.\n################################################################################\ndef throwBallIntoBins (n):\n    # Randomly throws a ball into n bins and returns\n    # the index of the bin from 1 to n.\n    return int(math.ceil(random.random()*n))\n\ndef throwManyBallsIntoBins (m,n):\n    # Randomly throws m balls into n bins and returns\n    # a list of indices from 1 to n\n    return [throwBallIntoBins(n) for _ in xrange(m)]\n\ndef checkForCollision (trial):\n    # Checks if there is a collision in a trial\n    # Returns true if there is a collision\n    return len(trial) > len(set(trial))\n\ndef runManyBallBinTrials (m,n,t):\n    # Runs t trials of throwning m balls into n\n    # Returns a list of t trials\n    return [throwManyBallsIntoBins(m,n) for _ in xrange(t)]\n\ndef runManyBallBinTrialsCheckCollision (trials):\n    # Returns a list of \"checkForCollision\" on each trial\n    return [checkForCollision(trial) for trial in trials]\n\ndef generateManyBirthdays(m):\n    # Randomly generates m birthdays\n    return throwManyBallsIntoBins (m,365)\n\ndef repeatingBirthdays (bday_trial):\n    # Returns true if there are shared birthdays and false otherwise\n    return checkForCollision(bday_trial)\n\ndef runManyBirthdayTrials (m,t):\n    # Runs t trials of generating random birthdays for m people and\n    # returns a list of T/F depending on whether there were repeating\n    # birthdays or not\n    trials = runManyBallBinTrials (m,365,t)\n    return runManyBallBinTrialsCheckCollision (trials)\n\ndef birthdayNoCollisionProb (m):\n    # Probability that there is no collision given that there are m birthdays\n    # Uses Stirling's approximation\n    # NOTE: Make sure you simplify your expression before plugging it in here.\n    return 1 - (math.exp(-m) * math.sqrt(365)/math.sqrt(365 - m) * (365/ (365 - m ))**(365 - m))\n    # YOUR CODE GOES HERE\n\ndef maxLoadFromTrial (trial):\n    # Returns the maximum load on any bin given a trial\n    return max([trial.count(i) for i in set(trial)])\n\ndef loadBalancingManyTrials (n,t):\n    # Returns a list of load balancing trials (list of bin numbers for each ball thrown)\n    return [throwManyBallsIntoBins(n,n) for _ in xrange(t)]\n\ndef loadBalancingManyTrialsMaxLoad (trials):\n    # Returns a list of maximum loads given trials\n    return [maxLoadFromTrial(trial) for trial in trials]\n\ndef loadBalancingManyTrialsCountBinI (trials,i):\n    # Returns a list of number of balls in bin i for each trial, given trials\n    return [trial.count(i) for trial in trials]\n\ndef getCumulativeCounts (trials):\n    # Returns distinct values in trials and cumulative counts of trials >= k for each k in values\n    trials.sort()\n    load_vals = sorted(list(set(trials)))\n    counts = [trials.count(v) for v in load_vals]\n    cumulative_counts = [sum(counts[i:]) for i in range(len(counts))]\n    return load_vals, cumulative_counts\n\ndef probApprox(k, n, with_e=False, with_one_minus_one_over_n=False):\n    # Just a function which approximates the probabilities as needed\n    # The probability being approximated is that bin 1 has load >= k\n    # This T/F arguments basically switch on/off the different things\n    # being asked in the parts (k) and (l).\n\n    # NOTE: Remember to clamp the probability at 1 if it goes above.\n    return NotImplemented\n    # YOUR CODE GOES HERE\n\n################################################################################\n# Actual code skeleton:\n################################################################################\ndef partA (mrange=[10,23,50,60], t=1000):\n    # Q1(a)\n\n    # trial_results is the list of results from running t trials of m birthdays for each m.\n    trial_results = []\n\n    ##################\n    # YOUR CODE GOES HERE\n\n    for m in mrange:\n        trial_results.append(sum(runManyBirthdayTrials(m, t))/t)\n    ##################\n\n    ticks = range(len(mrange)) # for plotting\n    plot.bar(ticks, trial_results)\n    plot.xlabel('Number of people')\n    # Add 0.5 to make labels centered\n    plot.xticks([tck + 0.5 for tck in ticks], mrange)\n    plot.ylabel('Fraction of trials with repeats')\n    plot.title('Birthday paradox')\n    plot.show()\n\ndef partB():\n    # Q1(b)\n\n    # Range of m values to check\n    mrange = xrange(1,81)\n\n    # NOTE: Don't use Stirling's approximation directly.\n    # Simplify your expression after using the approximation\n    # as much as possible before you plug it in here.\n    ##################\n    # YOUR CODE GOES HERE\n    pvals = list(map(birthdayNoCollisionProb, mrange))\n    ##################\n\n    # pvals is list of calculated probabilities for each value of m\n    plot.plot(mrange, pvals)\n    plot.ylabel('Probability of repeating birthdays',fontsize='medium')\n    plot.xlabel('Number of people',fontsize='medium')\n    plot.title('Birthday paradox')\n    plot.show()\n\ndef partC (nrange=[10,100,365,1000], t=1000):\n    # Q1(c)\n\n    for n in nrange:\n        print 'n =',n\n        mrange = sorted([int(0.1*n), int(0.3*n), int(math.sqrt(n))])\n        # trial_results is the list of results from running t trials of m birthdays for each m.\n        trial_results = []\n\n        ##################\n        # YOUR CODE GOES\n        for m in mrange:\n            vals = sum(runManyBallBinTrialsCheckCollision(runManyBallBinTrials(m, n, t)))/t\n            trial_results.append(vals)\n\n        ##################\n\n        ticks = range(len(mrange)) # for plotting\n        plot.bar(ticks, trial_results)\n        plot.xlabel('Number of balls')\n        # Add 0.5 to make labels centered\n        plot.xticks([tck + 0.5 for tck in ticks], mrange)\n        plot.ylabel('Fraction of trials with colliding balls')\n        plot.title('n=%i'%n)\n        plot.show()\n\n\ndef partD():\n    # Q1(d)\n\n    xvals = linspace(0.01,0.1,100)\n\n    ##################\n    # YOUR CODE GOES HERE\n    logvals = [math.log(1-i/1000 + 0.01) for i in range(100)]\n    ##################\n\n    # logvals - values of ln(1-x)\n    plot.plot(xvals, logvals)\n    plot.ylabel('ln(1-x)')\n    plot.xlabel('x')\n    plot.title('ln(1-x)')\n    plot.show()\n\ndef partE (nrange=[100,365,500,1000], t=1000):\n    # Q1(e)\n\n    for n in nrange:\n        print 'n =',n\n        mrange = [int(m) for m in linspace(1,2*math.sqrt(n),20)]\n        mrange = sorted(list(set(mrange))) # in order to remove duplicate entries.\n\n        # log_results is the list of the logarithm of the fractions from the experiments\n        log_results = []\n\n        ##################\n        # YOUR CODE GOES HERE\n        for m in mrange:\n            val = 1-sum(runManyBallBinTrialsCheckCollision(runManyBallBinTrials(m, n, t)))/t\n            log_results.append(-math.log(val))\n\n        ##################\n\n        plot.bar(mrange, log_results)\n        plot.xlabel('Number of balls')\n        plot.ylabel('-Ln(fraction of trials with collision)')\n        plot.title('n=%i'%n)\n        plot.show()\n\n\ndef partF (nrange=[100,365,500,1000], t=1000):\n    # Q1(f)\n\n    for n in nrange:\n        print 'n =',n\n        mrange = [int(m) for m in linspace(1,2*math.sqrt(n),20)]\n        mrange = sorted(list(set(mrange))) # in order to remove duplicate entries.\n\n        # This is the list of the logarithm of the fractions from the experiments\n        log_results = []\n        # This is m^2/2n\n        m_over_2n_squared = []\n\n        ##################\n        # YOUR CODE GOES\n        for m in mrange:\n            m_value = m*m/(2*n)\n            log_value = (1-sum(runManyBallBinTrialsCheckCollision(runManyBallBinTrials(m, n, t)))/t)\n            log_results.append(-math.log(log_value))\n            m_over_2n_squared.append(m_value)\n            calc_m = mrange[m_over_2n_squared.index(min(m_over_2n_squared, key=lambda x:abs(x-0.5)))]\n            trials_m = mrange[log_results.index(min(log_results, key=lambda x:abs(x-0.5)))]\n\n        ##################\n\n        print \"Trial m for which P(A) = 0.5:\", trials_m\n        print \"Calculated m for which P(A) = 0.5:\", calc_m\n        print \"Absolute difference in m values for P(A) = 0.5:\", abs(trials_m - calc_m)\n        plot.bar(mrange, log_results)\n        plot.plot(mrange, m_over_2n_squared)\n        plot.xlabel('Number of balls')\n        plot.ylabel('-Ln(fraction of trials with collision), m^2/2n')\n        plot.title('n=%i'%n)\n        plot.show()\n\n\ndef partG (nrange=[10,50,100,1000], t=1000):\n    # Q1(g)\n\n    for n in nrange:\n        print 'n =',n\n\n        ##################\n        # YOUR CODE GOES HERE\n        load_value = loadBalancingManyTrials(n, t)\n        max_loads = loadBalancingManyTrialsMaxLoad(load_value)\n        ##################\n\n        plot.hist(max_loads)\n        plot.xlabel('Max load on bins')\n        plot.ylabel('Number of trials')\n        plot.title('n=%i'%n)\n        plot.show()\n\n\ndef partH (nrange=[10,50,100,1000], t=1000):\n    # Q1(h)\n\n    for n in nrange:\n        print 'n =',n\n\n        ##################\n        # YOUR CODE GOES HERE\n        load_value = loadBalancingManyTrialsMaxLoad(loadBalancingManyTrials(n, t))\n        max_load_vals = sorted(list(set(load_value)))\n        cumulative_fracs = list(sum(list(x for x in max_load_vals if x>=k))/t for k in max_load_vals)\n\n        ##################\n\n        # max_load_vals is the different possible (distinct) maximum load values from the trials\n        # cumulative_fracs is the total fraction of trials which had max load >= k for each k in max_load_vals\n        plot.plot(max_load_vals, cumulative_fracs)\n        plot.xlabel('Max load on bins')\n        plot.ylabel('Fraction of trials')\n        plot.title('n=%i'%n)\n        plot.show()\n\n\n\ndef partI (nrange=[10,50,100,1000], t=1000):\n    # Q1(i)\n\n    for n in nrange:\n        print 'n =',n\n\n        ##################\n        # YOUR CODE GOES HERE\n\n        ##################\n\n        # X1 is the count in bin 1 for each trial\n        # max_load_vals is the different possible (distinct) maximum load values from the trials\n        # cumulative_fracs is the total fraction of trials which had max load >= k for each k in max_load_vals\n        # nX1_vals and cumulative_counts_nX1 are defined similarly to the oens above\n\n        # Part G:\n        plot.hist(X1)\n        plot.xlabel('Load in bin 1')\n        plot.ylabel('Number of trials')\n        plot.title('n=%i'%n)\n        plot.show()\n\n        # Part H:\n        plot.plot(X1_vals, cumulative_fracs_X1)\n        plot.xlabel('Load in bin 1')\n        plot.ylabel('Fraction of trials')\n        plot.title('n=%i'%n)\n        plot.show()\n\n        # Overlaying:\n        plot.plot(max_load_vals, cumulative_counts, label='max')\n        plot.plot(nX1_vals, cumulative_counts_nX1, label='n*X1')\n        plot.xlabel('Max load on bins, n*X1')\n        plot.ylabel('Fraction of trials')\n        plot.title('n=%i'%n)\n        plot.legend()\n        plot.show()\n\n\ndef partK (nrange=[10,50,100,1000], t=1000):\n    # Q1(k)\n\n    for n in nrange:\n        print 'n =',n\n\n        ##################\n        # YOUR CODE GOES HERE\n\n        ##################\n\n        # NOTE: these approximations aren't exactly reasonable as the question might mention\n        # They're actually upperbounds and might even be > 1.\n        # If you find a number > 1, clamp it to 1.\n\n        # X1_vals is the different possible (distinct) load values in bin 1 from the trials\n        # cumulative_fracs_X1 is the total fraction of trials which had max load >= k for each k in X1_vals\n        plot.plot(X1_vals, cumulative_fracs_X1, label='Trials')\n        # The labels below tell which probability is which in the question\n        plot.plot(X1_vals, prob_1, label='Prob with e')\n        plot.plot(X1_vals, prob_2, label='Prob without e')\n        plot.xlabel('Load in bin 1')\n        plot.ylabel('Fraction of trials')\n        plot.title('n=%i'%n)\n        plot.legend()\n        plot.show()\n\n\ndef partL (nrange=[10,50,100,1000], t=1000):\n    # Q1(l)\n\n    for n in nrange:\n        print 'n =',n\n\n        ##################\n        # YOUR CODE GOES HERE\n\n        ##################\n\n        # NOTE: these approximations aren't exactly reasonable as the question might mention\n        # They're actually upperbounds and might even be > 1.\n        # If you find a number > 1, clamp it to 1.\n\n        # X1_vals is the different possible (distinct) load values in bin 1 from the trials\n        # cumulative_fracs_X1 is the total fraction of trials which had max load >= k for each k in X1_vals\n        plot.plot(X1_vals, cumulative_fracs_X1, label='Trials')\n        # The labels below tell which probability is which in the question\n        plot.plot(X1_vals, prob_1, label='Prob with e')\n        plot.plot(X1_vals, prob_2, label='Prob without e')\n        plot.plot(X1_vals, prob_3, label='2*(e/k)^k')\n        plot.xlabel('Load in bin 1')\n        plot.ylabel('Fraction of trials')\n        plot.title('n=%i'%n)\n        plot.legend()\n        plot.show()\n\n\ndef partM ():\n    # Q1(m)\n\n    nrange = range(1,1001)\n\n    ##################\n    # YOUR CODE GOES HERE\n\n    ##################\n\n    # For which values of n does the inequality hold?\n\n    # k_lnk_minus_1 and ln_4n are the functions of n you are asked to plot\n    plot.plot(nrange, k_lnk_minus_1, label='ln(4n)*(ln(4n) - 1)')\n    plot.plot(nrange, ln_4n, label='ln(4n)')\n    plot.xlabel('n')\n    plot.legend()\n    plot.show()\n\ndef partN (nrange=[10,50,100,500,1000], t=1000):\n    # Q1(n)\n\n    prob_frac = []\n\n    ##################\n    # YOUR CODE GOES HERE\n\n    ##################\n\n    # prob_frac is the fraction of trials which resulted in a max load of >= ln(4n)\n    plot.plot(nrange, prob_frac)\n    plot.xlabel('Number of bins')\n    plot.ylabel('Fraction of trials with max load greater than ln(4n)')\n    plot.show()\n\n\n\npartmap = {'a':partA, 'A':partA,\n           'b':partB, 'B':partB,\n           'c':partC, 'C':partC,\n           'd':partD, 'D':partD,\n           'e':partE, 'E':partE,\n           'f':partF, 'F':partF,\n           'g':partG, 'G':partG,\n           'h':partH, 'H':partH,\n           'i':partI, 'I':partI,\n           'k':partK, 'K':partK,\n           'l':partL, 'L':partL,\n           'm':partM, 'M':partM,\n           'n':partN, 'N':partN}\n\n\n\nif __name__=='__main__':\n    # To make background white\n    mpl.rcParams['figure.facecolor'] = 'w'\n    import sys\n    if len(sys.argv) > 1:\n        if sys.argv[1] in partmap:\n            partmap[sys.argv[1]]()\n        else: print \"Invalid part number %s.\"%sys.argv[1]\n    else:\n        print \"Usage: python vl_skeleton.py [part number]\"\n        print \"Usage (interactive): python -i vl_skeleton.py\"\n","markers":{"markers":{"1":{"id":1,"range":[[275,0],[275,0]],"tailed":false,"reversed":true,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":19,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"},"578":{"id":578,"range":[[238,40],[238,50]],"tailed":true,"reversed":false,"valid":true,"invalidate":"overlap","persistent":true,"properties":{},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/howardchen/BluePrint/Q1.py","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"f11896014a0866a8de604278bbcc7f95aeed6cdd","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":15,"softTabs":true,"scrollTop":0,"scrollLeft":0,"displayBuffer":{"id":16,"softWrap":false,"editorWidthInChars":168,"tokenizedBuffer":{"bufferPath":"/Users/howardchen/BluePrint/curlcmd.txt","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":19,"softTabs":true,"scrollTop":5406,"scrollLeft":0,"displayBuffer":{"id":20,"softWrap":false,"editorWidthInChars":78,"tokenizedBuffer":{"bufferPath":"/Users/howardchen/BluePrint/Q1.py","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/howardchen/BluePrint/curlcmd.txt","focused":true,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/howardchen/BluePrint/curlcmd.txt":1397520284992,"/Users/howardchen/BluePrint/Q1.py":1397520284538},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":21453968},"tree-view":{"directoryExpansionStates":{},"selectedPath":"/Users/howardchen/BluePrint/curlcmd.txt","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}