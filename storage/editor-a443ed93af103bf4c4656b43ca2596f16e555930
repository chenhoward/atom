{"mode":"editor","version":"0.73.0","windowDimensions":{"x":209,"y":22,"width":1536,"height":1100},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/howardchen/Google Drive/61c/Project 2","buffers":[{"text":"/*\n * CS61C Spring 2014 Project2\n * Reminders:\n *\n * DO NOT SHARE CODE IN ANY WAY SHAPE OR FORM, NEITHER IN PUBLIC REPOS OR FOR DEBUGGING.\n *\n * This is one of the two files that you should be modifying and submitting for this project.\n */\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.lang.Math;\n\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.io.*;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.Mapper;\nimport org.apache.hadoop.mapreduce.Reducer;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.input.SequenceFileInputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;\nimport org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat;\nimport org.apache.hadoop.util.GenericOptionsParser;\n\npublic class SolveMoves {\n    public static class Map extends Mapper<IntWritable, MovesWritable, IntWritable, ByteWritable> {\n        /**\n         * Configuration and setup that occurs before map gets called for the first time.\n         *\n         **/\n        @Override\n        public void setup(Context context) {\n        }\n\n        /**\n         * The map function for the second mapreduce that you should be filling out.\n         */\n        @Override\n        public void map(IntWritable key, MovesWritable val, Context context) throws IOException, InterruptedException {\n            /* YOUR CODE HERE */\n        \t//for each parent in moveswriteable, emit parent as the key and child as the value\n            int[] moves = val.getMoves();\n            if (moves.length == 0) {\n                ByteWritable value = new ByteWritable(val.getValue());\n            } else {\n                for (int numMoves : val.getMoves()) {\n                    IntWritable newInt = new IntWritable(numMoves);\n                    ByteWritable newByte = new ByteWritable(val.getValue());\n                    context.write(newInt, newByte);\n                }\n            }\n\n        }\n    }\n\n    public static class Reduce extends Reducer<IntWritable, ByteWritable, IntWritable, MovesWritable> {\n\n        int boardWidth;\n        int boardHeight;\n        int connectWin;\n        boolean OTurn;\n        /**\n         * Configuration and setup that occurs before map gets called for the first time.\n         *\n         **/\n        @Override\n        public void setup(Context context) {\n            // load up the config vars specified in Proj2.java#main()\n            boardWidth = context.getConfiguration().getInt(\"boardWidth\", 0);\n            boardHeight = context.getConfiguration().getInt(\"boardHeight\", 0);\n            connectWin = context.getConfiguration().getInt(\"connectWin\", 0);\n            OTurn = context.getConfiguration().getBoolean(\"OTurn\", true);\n        }\n\n        /** Returns the correct piece to remove on the board represented as\n          * a char. */\n        private char getRemovedPiece() {\n            if (OTurn) {\n                return 'X';\n            } else {\n                return 'O';\n            }\n        }\n\n        /** Takes in a KEY that represents the game state and returns an int[] that\n         *  contains the integer representation of parent game states. */\n        private int[] generateParents(int key) {\n            String gameState = Proj2Util.gameUnhasher(key, boardWidth, boardHeight);\n            LinkedList<Integer> parentArr = new LinkedList<Integer>();\n            char removedPiece = getRemovedPiece();\n            for (int i = 0; i < boardHeight * boardWidth; i += boardHeight) {\n                for (int j = boardHeight - 1; j >= 0; j--) {\n                    char[] possibleParent = gameState.toCharArray();\n                    if (possibleParent[i + j] == ' ') {\n                        continue;\n                    } else {\n                        if(possibleParent[i + j] == removedPiece) {\n                            possibleParent[i + j] = ' ';\n                            parentArr.add(Proj2Util.gameHasher(new String\n                                (possibleParent), boardWidth, boardHeight));\n                        }\n                        break;\n                    }\n                }\n            }\n            int i = 0;\n            int[] parents = new int[parentArr.size()];\n            for(int j: parentArr) {\n                parents[i] = j;\n                i++;\n            }\n            return parents;\n        }\n\n        /**\n         * The reduce function for the first mapreduce that you should be filling out.\n         */\n        @Override\n        public void reduce(IntWritable key, Iterable<ByteWritable> values, Context context) throws IOException, InterruptedException {\n            ArrayList<Byte> list = new ArrayList<Byte>();\n            int index = 0;\n            int minIndex = Integer.MAX_VALUE;\n            int maxIndex = Integer.MIN_VALUE;\n            int tieIndex = Integer.MIN_VALUE;\n            byte minByte = Byte.MAX_VALUE;\n            byte maxByte = Byte.MIN_VALUE;\n            byte tieByte = Byte.MIN_VALUE;\n            boolean valid = false;\n            boolean won = false;\n            boolean tied = false;\n            for (ByteWritable child : values) {\n                Byte b = child.get();\n                list.add(b);\n                if (isValid(b)) {\n                   valid = true;\n                }\n                if (isWinningSituation(status(b))) {\n                    if (getMoves(b) < minByte) {\n                        minByte = getMoves(b);\n                        minIndex = index;\n                        won = true;\n                    }\n\n                } else if (isTiedSituation(status(b)) && !won) {\n                    if (getMoves(b) > tieByte) {\n                        tieByte = getMoves(b);\n                        tieIndex = index;\n                        tied = true;\n                    }\n                } else if (getMoves(b) > maxByte && (!won || !tied)) {\n                    maxByte = getMoves(b);\n                    maxIndex = index;\n                }\n                index ++;\n            }\n            if (!valid) {\n              return;\n            } else {\n                int[] parents = generateParents(key.get());\n                byte value;\n                if (won) {\n                    value= getValue(list, minIndex);\n                } else if (tied) {\n                    value = getValue(list, tieIndex);\n                } else {\n                    value = getValue(list, maxIndex);\n                }\n                context.write(key, new MovesWritable(value, parents));\n            }\n        }\n\n        /** Returns true iff val is a winning game state. */\n        private boolean isWinningSituation(byte val) {\n            return ((val == 1) & OTurn) | ((val == 2) & !OTurn);\n        }\n\n        /** Returns true iff val is a tied game state. */\n        private boolean isTiedSituation(byte val) {\n            return val == 3;\n        }\n\n        /** Returns the status that is represented by VAL. */\n        private byte status(byte val) {\n            return (byte) (val & 3);\n        }\n\n        /** Returns the number of moves represented by VAL. */\n        private byte getMoves(byte val) {\n            return (byte) (val >>> 2);\n        }\n\n        private boolean isValid(byte val) {\n            return val < 4;\n        }\n\n        /** Returns the correct byte value for an INDEX in a list of\n          * bytes LIST.*/\n        private byte getValue(List<Byte> list, int index) {\n            return (byte) (list.get(index) + 4);\n        }\n    }\n}\n","markers":{"markers":{"1":{"id":1,"range":[[102,57],[102,57]],"tailed":false,"reversed":true,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":36,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/howardchen/Google Drive/61c/Project 2/SolveMoves.java","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"b189253e435542e3132d91b3053c3d64ad0e084d","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":36,"softTabs":true,"scrollTop":3171,"scrollLeft":29,"displayBuffer":{"id":37,"softWrap":false,"editorWidthInChars":127,"tokenizedBuffer":{"bufferPath":"/Users/howardchen/Google Drive/61c/Project 2/SolveMoves.java","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/howardchen/Google Drive/61c/Project 2/SolveMoves.java","focused":true,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/howardchen/Google Drive/61c/Project 2/SolveMoves.java":1395336945126},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":28818},"tree-view":{"directoryExpansionStates":{},"selectedPath":"/Users/howardchen/Google Drive/61c/Project 2/SolveMoves.java","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}