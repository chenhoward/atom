{"mode":"editor","version":1,"windowDimensions":{"x":151,"y":311,"width":1686,"height":1090},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/howardchen/Google Drive","buffers":[{"text":"/*\n * Proj 3-2 SKELETON\n */\n\n#include <float.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <cuda_runtime.h>\n#include <cutil.h>\n#include \"utils.h\"\n#include <math.h>\n\n\n/* Squares the difference an IMAGE of width I_WIDTH and a TEMP of T_WIDTH getting offset\n   by OFFSETX and OFFSETY and the result is stored in RESULT. */\n__global__ void distanceKernel(float *image, float *temp, int i_width, int offsetX, int offsetY, int t_width, float *result) {\n  int thisThreadX = blockIdx.x * blockDim.x + threadIdx.x;\n  int thisThreadY = blockIdx.y *blockDim.y + threadIdx.y;\n  int validX = thisThreadX < t_width;\n  int validY = thisThreadY < t_width;\n  if (validX && validY) {\n    float valueI = image[thisThreadX + offsetX + i_width * (thisThreadY + offsetY)];\n    float valueT = temp[thisThreadX + thisThreadY * t_width];\n    float value = (valueI - valueT) * (valueI - valueT);\n    result[thisThreadX + thisThreadY * t_width] = value;\n  }\n}\n\n/* Does a horizontal flip of an image ARR of size WIDTH. */\n__global__ void flip_horizontal(float *arr, int width) {\n  /* YOU MAY WISH TO IMPLEMENT THIS  */\n  int thisThreadY = blockIdx.y * blockDim.y + threadIdx.y;\n  int thisThreadX = blockIdx.x * blockDim.x + threadIdx.x;\n  int validY = thisThreadY < (width / 2);\n  int validX = thisThreadX < width;\n  if (validX && validY) {\n    int index1 = thisThreadY + thisThreadX * width;\n    int index2 = thisThreadX*width + (width - 1) - thisThreadY;\n    float value = arr[index1];\n    arr[index1] = arr[index2];\n    arr[index2] = value;\n  }\n}\n\n\n/* Transposes the image ARR of size WIDTH.*/\n__global__ void transpose(float *arr, int width) {\n  /* YOU MAY WISH TO IMPLEMENT THIS */\n  int thisThreadX = blockIdx.x*blockDim.x + threadIdx.x;\n  int thisThreadY = blockIdx.y*blockDim.y + threadIdx.y;\n  int cond1 = thisThreadX < thisThreadY;\n  int cond2 = thisThreadY < width;\n  if (cond1 && cond2) {\n    int index1 = thisThreadX + width * thisThreadY;\n    int index2 = thisThreadX * width + thisThreadY;\n    float value = arr[index1];\n    arr[index1] = arr[index2];\n    arr[index2] = value;\n  }\n}\n\n\n/* Takes in ARR, and array of floats of size LEN at the LEVEL of reduction. */\n__global__ void reductionKernel(float* arr, int len, long level) {\n  int thisThreadIndex = blockIdx.x*blockDim.x + threadIdx.x;\n  int cond = thisThreadIndex < (len / level / 2);\n  if (cond) {\n    int index = thisThreadIndex * level * 2;\n    arr[index] += arr[index + level];\n  }\n}\n\n/* ReductionGPU */\nvoid reductionGPU(float* arr, int len) {\n  int threads_per_block = 256; // initially, each block takes care of 512 elements\n  int blocks_per_grid = (len/(2 * threads_per_block));\n  long level = 1;\n  while (level != len) {\n    dim3 dim_blocks_per_grid(blocks_per_grid, 1);\n    dim3 dim_threads_per_block(threads_per_block, 1, 1);\n    reductionKernel<<<dim_blocks_per_grid, dim_threads_per_block>>>(arr, len, level);\n    cudaThreadSynchronize();\n    CUT_CHECK_ERROR(\"\");\n    level *= 2;\n    if (blocks_per_grid / 2 != 0) {\n      blocks_per_grid = blocks_per_grid / 2;\n    }\n\n  }\n}\n\n\n\n/* Returns the squared Euclidean distanceem between TEMPLATE and IMAGE. The size of IMAGE\n * is I_WIDTH * I_HEIGHT, while TEMPLATE is square with side length T_WIDTH. The template\n * image should be flipped, rotated, and translated across IMAGE.\n */\nfloat calc_min_dist(float *image, int i_width, int i_height, float *temp, int t_width) {\n  // float* image and float* temp are pointers to GPU addressible memory\n  // You MAY NOT copy this data back to CPU addressible memory and you MAY\n  // NOT perform any computation using values from image or temp on the CPU.\n  // The only computation you may perform on the CPU directly derived from distance\n  // values is selecting the minimum distance value given a calculated distance and a\n  // \"min so far\"\n  /* YOUR CODE HERE */\n  /* Have one kernel for SQ DIFF, another to ADD SUMS */\n\n  //int threads_per_block = 512;\n  int x_threads_per_block = 32;\n  int y_threads_per_block = 16;\n  int x_blocks_per_grid = t_width/x_threads_per_block + 1;\n  int y_blocks_per_grid = t_width/y_threads_per_block + 1;\n  // 3-dim vector objects to initialize values\n  dim3 dim_blocks_per_grid(x_blocks_per_grid, y_blocks_per_grid);\n  dim3 dim_threads_per_block(x_threads_per_block, y_threads_per_block, 1);\n\n  size_t sq_arraySize = t_width * t_width * sizeof(float);\n  float* sq_diff;\n  CUDA_SAFE_CALL(cudaMalloc(&sq_diff, sq_arraySize));\n  float abs_min = FLT_MAX;\n  for (int rotations = 4; rotations > 0; rotations--) {\n    int x = 0, y = 0;\n    for (x = 0; x <= i_width - t_width; x++) {\n      for (y= 0; y <= i_height - t_width; y++) {\n        distanceKernel<<<dim_blocks_per_grid, dim_threads_per_block>>>(image, temp, i_width, x, y, t_width, sq_diff);\n        cudaThreadSynchronize();\n        CUT_CHECK_ERROR(\"\");\n        reductionGPU(sq_diff, (int) t_width*t_width);\n        float gpu_result;\n        CUDA_SAFE_CALL(cudaMemcpy(&gpu_result, sq_diff, sizeof(float), cudaMemcpyDeviceToHost));\n        if (gpu_result < abs_min) {\n          abs_min = gpu_result;\n        }\n      }\n    }\n    flip_horizontal<<<dim_blocks_per_grid, dim_threads_per_block>>>(temp, t_width);\n    x = 0, y = 0;\n    for (x = 0; x <= i_width - t_width; x++) {\n      for (y= 0; y <= i_height - t_width; y++) {\n        distanceKernel<<<dim_blocks_per_grid, dim_threads_per_block>>>(image, temp, i_width, x, y, t_width, sq_diff);\n        cudaThreadSynchronize();\n        CUT_CHECK_ERROR(\"\");\n        reductionGPU(sq_diff, (int) t_width*t_width);\n        float gpu_result;\n        CUDA_SAFE_CALL(cudaMemcpy(&gpu_result, sq_diff, sizeof(float), cudaMemcpyDeviceToHost));\n        if (gpu_result < abs_min) {\n          abs_min = gpu_result;\n        }\n      }\n    }\n    transpose<<<dim_blocks_per_grid, dim_threads_per_block>>>(temp, t_width);\n  }\n  CUDA_SAFE_CALL(cudaFree(sq_diff));\n  return abs_min;\n}\n","markers":{"markers":{"1":{"id":1,"range":[[71,0],[71,0]],"tailed":false,"reversed":true,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":28,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[{"patches":[{"oldRange":[[43,0],[43,0]],"newRange":[[43,0],[44,0]],"oldText":"","newText":"\n","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[44,0],[44,0]],"newRange":[[44,0],[44,0]],"oldText":"","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[45,43],[45,44]],"newRange":[[45,43],[45,43]],"oldText":"*","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[45,43],[45,44]],"newRange":[[45,43],[45,43]],"oldText":"/","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[59,1],[59,1]],"newRange":[[59,1],[59,2]],"oldText":"","newText":"*","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[59,2],[59,2]],"newRange":[[59,2],[59,3]],"oldText":"","newText":"/","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"range":[[59,2],[59,2]]},"newParams":{"range":[[59,3],[59,3]]},"deserializer":"MarkerPatch"},{"oldRange":[[59,3],[59,3]],"newRange":[[59,3],[60,0]],"oldText":"","newText":"\n","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[60,0],[60,0]],"newRange":[[60,0],[60,0]],"oldText":"","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[60,0],[60,0]],"newRange":[[60,0],[60,1]],"oldText":"","newText":"o","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"reversed":false,"range":[[60,1],[60,1]]},"newParams":{"reversed":true,"range":[[60,0],[60,1]]},"deserializer":"MarkerPatch"},{"oldRange":[[60,0],[60,1]],"newRange":[[60,0],[60,0]],"oldText":"o","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[60,0],[60,0]],"newRange":[[60,0],[61,0]],"oldText":"","newText":"\n","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[61,0],[61,0]],"newRange":[[61,0],[61,0]],"oldText":"","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[61,0],[61,0]],"newRange":[[61,0],[71,1]],"oldText":"","newText":"/* Transposes the square array ARR. */\n__global__ void transpose(float *arr, int width) {\n    /* YOU MAY WISH TO IMPLEMENT THIS */\n    unsigned int col = blockIdx.x*blockDim.x + threadIdx.x;\n    unsigned int row = blockIdx.y*blockDim.y + threadIdx.y;\n    if (col < row && row < width) {\n    \tfloat temp = *(arr+row*width+col);\n    \t*(arr+row*width+col) = *(arr+col*width+row);\n    \t*(arr+col*width+row) = temp;    \n    }\n}","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[112,85],[112,86]],"newRange":[[112,85],[112,85]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[109,74],[109,75]],"newRange":[[109,74],[109,74]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[90,85],[90,86]],"newRange":[[90,85],[90,85]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[88,49],[88,50]],"newRange":[[88,49],[88,49]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[87,24],[87,25]],"newRange":[[87,24],[87,24]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[82,18],[82,19]],"newRange":[[82,18],[82,18]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[69,33],[69,37]],"newRange":[[69,33],[69,33]],"oldText":"    ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[45,42],[45,43]],"newRange":[[45,42],[45,42]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[47,0],[47,0]],"newRange":[[47,0],[48,0]],"oldText":"","newText":"  /* YOU MAY WISH TO IMPLEMENT THIS \n","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[48,0],[49,0]],"newRange":[[48,0],[48,0]],"oldText":"  /* YOU MAY WISH TO IMPLEMENT THIS */\n","newText":"","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[28,0],[28,0]],"newRange":[[28,0],[29,0]],"oldText":"","newText":"/* Does a horizontal flip of an image ARR of size WIDTH. \n","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[29,0],[30,0]],"newRange":[[29,0],[29,0]],"oldText":"/* Does a horizontal flip of an image ARR of size WIDTH. */\n","newText":"","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[30,0],[30,0]],"newRange":[[30,0],[31,0]],"oldText":"","newText":"  /* YOU MAY WISH TO IMPLEMENT THIS \n","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[31,0],[32,0]],"newRange":[[31,0],[31,0]],"oldText":"  /* YOU MAY WISH TO IMPLEMENT THIS */\n","newText":"","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[42,0],[42,0]],"newRange":[[42,0],[53,0]],"oldText":"","newText":"}*/\n/* Does a horizontal flip of the array arr */\n__global__ void flip_horizontal(float *arr, int width) {\n    /* YOU MAY WISH TO IMPLEMENT THIS */\n    unsigned int col = blockIdx.y*blockDim.y + threadIdx.y;\n    unsigned int row = blockIdx.x*blockDim.x + threadIdx.x;\n    if (col < (width/2) && row < width) {\n      float temp = *(arr+col+row*width);\n      *(arr+col+row*width) = *(arr+row*width+(width-1)-col);\n      *(arr+row*width+(width-1)-col) = temp;\n    }\n","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[56,0],[56,0]],"newRange":[[56,0],[57,0]],"oldText":"","newText":"/* Transposes the image ARR of size WIDTH.*/\n","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[57,0],[58,0]],"newRange":[[57,0],[57,0]],"oldText":"/* Transposes the image ARR of size WIDTH.\n","newText":"","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[58,0],[58,0]],"newRange":[[58,0],[59,0]],"oldText":"","newText":"  /* YOU MAY WISH TO IMPLEMENT THIS */\n","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[59,0],[60,0]],"newRange":[[59,0],[59,0]],"oldText":"  /* YOU MAY WISH TO IMPLEMENT THIS \n","newText":"","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[70,0],[82,0]],"newRange":[[70,0],[70,0]],"oldText":"}*/\n\n/* Transposes the square array ARR. */\n__global__ void transpose(float *arr, int width) {\n    /* YOU MAY WISH TO IMPLEMENT THIS */\n    unsigned int col = blockIdx.x*blockDim.x + threadIdx.x;\n    unsigned int row = blockIdx.y*blockDim.y + threadIdx.y;\n    if (col < row && row < width) {\n    \tfloat temp = *(arr+row*width+col);\n    \t*(arr+row*width+col) = *(arr+col*width+row);\n    \t*(arr+col*width+row) = temp;\n    }\n","newText":"","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[28,0],[28,0]],"newRange":[[28,0],[29,0]],"oldText":"","newText":"/* Does a horizontal flip of an image ARR of size WIDTH. */\n","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[29,0],[30,0]],"newRange":[[29,0],[29,0]],"oldText":"/* Does a horizontal flip of an image ARR of size WIDTH. \n","newText":"","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[30,0],[30,0]],"newRange":[[30,0],[31,0]],"oldText":"","newText":"  /* YOU MAY WISH TO IMPLEMENT THIS  */\n","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[31,0],[32,0]],"newRange":[[31,0],[31,0]],"oldText":"  /* YOU MAY WISH TO IMPLEMENT THIS \n","newText":"","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[36,0],[36,0]],"newRange":[[36,0],[37,0]],"oldText":"","newText":"    int index1 = thisThreadY + thisThreadX * width;\n","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[37,0],[38,0]],"newRange":[[37,0],[37,0]],"oldText":"    int index1 = thisThreadX + thisThreadY * width;\n","newText":"","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[42,0],[53,0]],"newRange":[[42,0],[42,0]],"oldText":"}*/\n/* Does a horizontal flip of the array arr */\n__global__ void flip_horizontal(float *arr, int width) {\n    /* YOU MAY WISH TO IMPLEMENT THIS */\n    unsigned int col = blockIdx.y*blockDim.y + threadIdx.y;\n    unsigned int row = blockIdx.x*blockDim.x + threadIdx.x;\n    if (col < (width/2) && row < width) {\n      float temp = *(arr+col+row*width);\n      *(arr+col+row*width) = *(arr+row*width+(width-1)-col);\n      *(arr+row*width+(width-1)-col) = temp;\n    }\n","newText":"","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[65,0],[65,0]],"newRange":[[65,0],[69,0]],"oldText":"","newText":"  int cond = thisThreadIndex < (len / level / 2);\n  if (cond) {\n    int index = thisThreadIndex * level * 2;\n    arr[index] += arr[index + level];\n","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[69,0],[71,0]],"newRange":[[69,0],[69,0]],"oldText":"  if (thisThreadIndex < len / (level * 2)) {\n    arr[thisThreadIndex * (level * 2)] += arr[thisThreadIndex * (level * 2) + level];\n","newText":"","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[62,0],[62,0]],"newRange":[[62,0],[63,0]],"oldText":"","newText":"/* Takes in ARR, and array of floats of size LEN at the LEVEL of reduction. */\n","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[63,0],[64,0]],"newRange":[[63,0],[63,0]],"oldText":"/* Adds the euc_sums, using GPU. */\n","newText":"","normalizeLineEndings":{"normalizeLineEndings":false},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"}],"redoStack":[],"deserializer":"History"},"filePath":"/Users/howardchen/Google Drive/calc_dist.cu","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"2377beff068eda0d0dc3e4a263aaa1bca34a66c8","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":28,"softTabs":true,"scrollTop":216,"scrollLeft":0,"displayBuffer":{"id":29,"softWrap":false,"editorWidthInChars":147,"tokenizedBuffer":{"bufferPath":"/Users/howardchen/Google Drive/calc_dist.cu","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/howardchen/Google Drive/calc_dist.cu","focused":true,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/howardchen/Google Drive/calc_dist.cu":1398045157209},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":18358269},"tree-view":{"directoryExpansionStates":{},"selectedPath":"/Users/howardchen/Google Drive/calc_dist.cu","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}